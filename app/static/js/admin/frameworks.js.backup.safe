// Modify initialization to ensure it runs regardless of when the script is loaded
(function initWhenReady() {
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initWhenReady);
        return;
    }

// REPLACE the opening of the redundant DOMContentLoaded listener with an IIFE so it runs immediately
(function domReadyInit() {
    // Prevent multiple initializations if this script is executed more than once
    if (window.__frameworkPageInitialized) {
        return;
    }
    window.__frameworkPageInitialized = true;

    // Choose Your Approach - Section Management
    const chooseApproachSection = document.querySelector('.approach-hero');
    const existingFrameworksSection = document.getElementById('existingFrameworksSection');
    const useExistingChoice = document.getElementById('useExistingChoice');
    const createNewChoice = document.getElementById('createNewChoice');

    // Handle "Use Existing Framework" choice
    if (useExistingChoice) {
        useExistingChoice.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();

            if (!chooseApproachSection) return;

            // Add progressive disclosure - collapse the choice section
            chooseApproachSection.classList.add('hero-minified');

            // Wait until the CSS transition ends before scrolling for smoother UX
            const onTransitionEnd = () => {
                chooseApproachSection.removeEventListener('transitionend', onTransitionEnd);
                if (existingFrameworksSection) {
                    setTimeout(() => {
                        existingFrameworksSection.scrollIntoView({
                            behavior: 'smooth',
                            block: 'start'
                        });
                    }, 200); // small delay post-collapse for better visibility
                }
            };

            // Fallback timeout in case transitionend doesn't fire
            setTimeout(onTransitionEnd, 1200); // Match new 0.8s transition + buffer

            chooseApproachSection.addEventListener('transitionend', onTransitionEnd);
        });
    }

    // Handle "Create New Framework" choice
    if (createNewChoice) {
        createNewChoice.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Redirect to framework wizard (existing functionality)
            window.location.href = '/admin/frameworks/wizard';
        });
    }

    // Add hover effects for choice cards
    const choiceCards = document.querySelectorAll('.choice-card');
    choiceCards.forEach(card => {
        card.addEventListener('mouseenter', function() {
            this.style.transform = 'scale(1.02)';
        });
        
        card.addEventListener('mouseleave', function() {
            this.style.transform = 'scale(1)';
        });
    });

    // Helper function to generate slug from field name
    function generateSlug(fieldName) {
        if (!fieldName) return '';
        // Convert to lowercase, replace spaces and special chars with underscores
        let slug = fieldName.toLowerCase().replace(/[^a-zA-Z0-9\s-]/g, '');
        slug = slug.replace(/[\s-]+/g, '_').replace(/^_+|_+$/g, '');
        return slug;
    }

    const cardDeck = document.getElementById('frameworkCardDeck');
    const scrollLeftBtn = document.getElementById('scrollLeft');
    const scrollRightBtn = document.getElementById('scrollRight');

    // Only initialize scroll functionality if the elements exist
    if (cardDeck && scrollLeftBtn && scrollRightBtn) {
        function updateScrollButtons() {
            scrollLeftBtn.disabled = cardDeck.scrollLeft === 0;
            scrollRightBtn.disabled = 
                cardDeck.scrollLeft + cardDeck.clientWidth >= cardDeck.scrollWidth;
        }

        scrollLeftBtn.addEventListener('click', function() {
            cardDeck.scrollBy({
                left: -cardDeck.clientWidth,
                behavior: 'smooth'
            });
        });

        scrollRightBtn.addEventListener('click', function() {
            cardDeck.scrollBy({
                left: cardDeck.clientWidth,
                behavior: 'smooth'
            });
        });

        // Initial button state
        updateScrollButtons();

        // Update scroll buttons on scroll and resize
        cardDeck.addEventListener('scroll', updateScrollButtons);
        window.addEventListener('resize', updateScrollButtons);
    }

    // Data Points Management with Sidebar Drawer
    const dataPointsContainer = document.getElementById('dataPointsContainer');
    const addDataPointBtn = document.getElementById('addDataPoint');
    const createFrameworkForm = document.getElementById('createFrameworkForm');
    const addTopicBtn = document.getElementById('addTopicBtn');
    const topicsContainer = document.getElementById('topicsContainer');
    const topicModal = new bootstrap.Modal(document.getElementById('topicModal'));
    const saveTopic = document.getElementById('saveTopic');
    
    // Drawer elements
    const dataPointDrawer = document.getElementById('dataPointDrawer');
    const drawerOverlay = document.getElementById('drawerOverlay');
    const closeDrawerBtn = document.getElementById('closeDrawer');
    const cancelDataPointBtn = document.getElementById('cancelDataPoint');
    const saveDataPointBtn = document.getElementById('saveDataPoint');
    const dataPointForm = document.getElementById('dataPointForm');
    const drawerTitle = document.getElementById('drawerTitle');
    const emptyState = document.getElementById('emptyDataPointsState');
    
    let currentFrameworkId = null;
    let topics = [];
    let customTopics = [];
    let dataPoints = [];
    let editingDataPointIndex = -1;

    // Helper function to update stats with animation
    function updateStatWithAnimation(elementId, newValue) {
        const element = document.getElementById(elementId);
        if (element) {
            const skeletonLoader = element.querySelector('.skeleton-loader');
            if (skeletonLoader) {
                skeletonLoader.style.opacity = '0';
                setTimeout(() => {
                    element.textContent = newValue;
                    element.style.opacity = '0';
                    element.style.transform = 'translateY(10px)';
                    setTimeout(() => {
                        element.style.transition = 'all 0.3s ease';
                        element.style.opacity = '1';
                        element.style.transform = 'translateY(0)';
                    }, 50);
                }, 200);
            } else {
                element.textContent = newValue;
            }
        }
    }

    // Initialize page
    loadCustomTopics();
    initializeFrameworkStats();

    function initializeFrameworkStats() {
        fetch('/admin/frameworks/stats', { credentials: 'include' })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Remove skeleton loaders and update with real data
                    updateStatWithAnimation('total-frameworks-stat', data.total_frameworks);
                    updateStatWithAnimation('active-assignments-stat', data.active_assignments);
                    updateStatWithAnimation('overall-coverage-stat', `${data.overall_coverage}%`);
                    
                    const recentActivityDate = data.recent_activity ? new Date(data.recent_activity) : null;
                    if (recentActivityDate) {
                        updateStatWithAnimation('recent-activity-stat', recentActivityDate.toLocaleDateString());
                    } else {
                        updateStatWithAnimation('recent-activity-stat', 'N/A');
                    }
                }
            })
            .catch(error => {
                // Show error state
                updateStatWithAnimation('total-frameworks-stat', 'Error');
                updateStatWithAnimation('active-assignments-stat', 'Error');
                updateStatWithAnimation('overall-coverage-stat', 'Error');
                updateStatWithAnimation('recent-activity-stat', 'Error');
            });

        fetch('/admin/frameworks/chart_data', { credentials: 'include' })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    renderTopFrameworksChart(data.top_5_frameworks);
                    renderFrameworkTypeChart(data.framework_type_distribution);
                }
            })
            .catch(error => console.error('Error loading framework chart data:', error));
    }

    function renderTopFrameworksChart(frameworks) {
        const ctx = document.getElementById('topFrameworksChart').getContext('2d');
        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: frameworks.map(f => f.name),
                datasets: [{
                    label: 'Coverage %',
                    data: frameworks.map(f => f.coverage),
                    backgroundColor: 'rgba(75, 192, 192, 0.6)',
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 1,
                    borderRadius: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                aspectRatio: 2,
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        grid: {
                            color: 'rgba(0,0,0,0.05)'
                        }
                    },
                    x: {
                        grid: {
                            display: false
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'bottom'
                    }
                }
            }
        });
    }

    function renderFrameworkTypeChart(distribution) {
        const ctx = document.getElementById('frameworkTypeChart').getContext('2d');
        new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: ['Global', 'Company'],
                datasets: [{
                    data: [distribution.global, distribution.company],
                    backgroundColor: ['rgba(23, 162, 184, 0.6)', 'rgba(47, 71, 40, 0.6)'],
                    borderColor: ['rgba(23, 162, 184, 1)', 'rgba(47, 71, 40, 1)'],
                    borderWidth: 1,
                    hoverOffset: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                cutout: '60%',
                plugins: {
                    legend: {
                        position: 'bottom'
                    }
                }
            }
        });
    }
    
    // Topic Management Functions
    function loadCustomTopics() {
    fetch('/admin/topics/custom', { credentials: 'include' })
            .then(response => response.json())
            .then(data => {
                customTopics = data;
                updateTopicDropdowns();
            })
            .catch(error => console.error('Error loading custom topics:', error));
    }

    function updateTopicDropdowns() {
        const parentTopicSelect = document.getElementById('parentTopic');
        const allTopicSelects = document.querySelectorAll('.topic-select');
        
        // Update parent topic dropdown in modal
        parentTopicSelect.innerHTML = '<option value="">-- Root Topic --</option>';
        topics.concat(customTopics).forEach(topic => {
            addTopicOptionRecursive(parentTopicSelect, topic, '');
        });
        
        // Update topic selects in data point rows
        allTopicSelects.forEach(select => {
            const currentValue = select.value;
            select.innerHTML = '<option value="">-- Select Topic --</option>';
            topics.concat(customTopics).forEach(topic => {
                addTopicOptionRecursive(select, topic, '');
            });
            select.value = currentValue;
        });
    }

    function addTopicOptionRecursive(select, topic, prefix) {
        const option = document.createElement('option');
        option.value = topic.topic_id;
        option.textContent = prefix + topic.name;
        if (topic.is_custom) option.textContent += ' (Custom)';
        select.appendChild(option);
        
        if (topic.children) {
            topic.children.forEach(child => {
                addTopicOptionRecursive(select, child, prefix + '  ');
            });
        }
    }

    function displayTopicsTree() {
        topicsContainer.innerHTML = '';
        if (topics.length === 0 && customTopics.length === 0) {
            topicsContainer.innerHTML = '<p class="text-muted">No topics created yet. Click "Add Topic" to create one.</p>';
            return;
        }
        
        const allTopics = topics.concat(customTopics);
        allTopics.forEach(topic => {
            if (!topic.parent_id) { // Only display root topics
                const topicElement = createTopicElement(topic);
                topicsContainer.appendChild(topicElement);
            }
        });
    }

    function createTopicElement(topic, level = 0) {
        const div = document.createElement('div');
        div.className = 'topic-item';
        div.style.marginLeft = (level * 20) + 'px';
        
        const indent = '  '.repeat(level);
        const customBadge = topic.is_custom ? '<span class="badge bg-info">Custom</span>' : '';
        const fieldCount = topic.field_count || 0;
        
        div.innerHTML = `
            <div class="d-flex justify-content-between align-items-center p-2 border rounded mb-2">
                <div>
                    <strong>${indent}${topic.name}</strong> ${customBadge}
                    <small class="text-muted d-block">${topic.description || 'No description'}</small>
                    <small class="text-info">${fieldCount} field(s)</small>
                </div>
                <div>
                    <button class="btn btn-sm btn-outline-primary edit-topic" data-topic-id="${topic.topic_id}">
                        <i class="fas fa-edit"></i>
                    </button>
                    <button class="btn btn-sm btn-outline-danger delete-topic" data-topic-id="${topic.topic_id}">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>
        `;
        
        // Add children recursively
        if (topic.children) {
            topic.children.forEach(child => {
                const childElement = createTopicElement(child, level + 1);
                div.appendChild(childElement);
            });
        }
        
        return div;
    }

// Add Topic & Topic-Modal handlers (only if elements exist on the page)
if (addTopicBtn && topicModal && saveTopic) {
    // Open Topic modal
    addTopicBtn.addEventListener('click', function() {
        topicModal.show();
    });

    // Save Topic inside modal
    saveTopic.addEventListener('click', function() {
        const formData = {
            name: document.getElementById('topicName').value,
            description: document.getElementById('topicDescription').value,
            parent_id: document.getElementById('parentTopic').value || null,
            framework_id: document.getElementById('isCustomTopic').checked ? null : currentFrameworkId,
            company_id: document.getElementById('isCustomTopic').checked ? getCurrentCompanyId() : null
        };

        if (!formData.name) {
            alert('Topic name is required');
            return;
        }

        fetch('/admin/topics', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(formData)
        })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                alert('Error: ' + data.error);
            } else {
                topicModal.hide();
                document.getElementById('topicForm').reset();
                if (formData.company_id) {
                    loadCustomTopics();
                } else {
                    loadFrameworkTopics(currentFrameworkId);
                }
            }
        })
        .catch(error => {
            console.error('Error saving topic:', error);
            alert('Error saving topic');
        });
    });
}

    function getCurrentCompanyId() {
        // This should be set from the session or user context
        return window.currentCompanyId || null;
    }

    function loadFrameworkTopics(frameworkId) {
        if (!frameworkId) return;
        
    fetch(`/admin/frameworks/${frameworkId}/topics`, { credentials: 'include' })
            .then(response => response.json())
            .then(data => {
                topics = data;
                displayTopicsTree();
                updateTopicDropdowns();
            })
            .catch(error => console.error('Error loading framework topics:', error));
    }

    // Data Point Drawer Management
if (addDataPointBtn) {
    addDataPointBtn.addEventListener('click', function() {
        openDataPointDrawer();
    });
}

    // Drawer Event Listeners
if (closeDrawerBtn) {
    closeDrawerBtn.addEventListener('click', function() {
        closeDataPointDrawer();
    });
}

if (cancelDataPointBtn) {
    cancelDataPointBtn.addEventListener('click', function() {
        closeDataPointDrawer();
    });
}

if (drawerOverlay) {
    drawerOverlay.addEventListener('click', function() {
        closeDataPointDrawer();
    });
}

if (saveDataPointBtn) {
    saveDataPointBtn.addEventListener('click', function() {
        saveDataPoint();
    });
}

    // Handle computed field toggle in drawer
const dpComputedCheckbox = document.getElementById('dpComputed');
const formulaSection = document.getElementById('formulaSection');

if (dpComputedCheckbox && formulaSection) {
    dpComputedCheckbox.addEventListener('change', function() {
        if (this.checked) {
            formulaSection.style.display = 'block';
        } else {
            formulaSection.style.display = 'none';
        }
    });
}

    // Handle advanced fields toggle
    const advancedFieldsToggle = document.querySelector('[data-bs-target="#advancedFields"]');
    const toggleIcon = document.querySelector('.toggle-icon');
    
    if (advancedFieldsToggle && toggleIcon) {
        advancedFieldsToggle.addEventListener('click', function() {
            setTimeout(() => {
                const isExpanded = document.getElementById('advancedFields').classList.contains('show');
                toggleIcon.classList.toggle('rotated', isExpanded);
            }, 150);
        });
    }

    // Auto-generate field code in drawer
    const dpNameInput = document.getElementById('dpName');
    const dpFieldCodeInput = document.getElementById('dpFieldCode');
    
    if (dpNameInput && dpFieldCodeInput) {
        dpNameInput.addEventListener('input', function() {
            if (!dpFieldCodeInput.value || dpFieldCodeInput.hasAttribute('data-auto-generated')) {
                const slug = generateSlug(this.value);
                dpFieldCodeInput.value = slug;
                dpFieldCodeInput.setAttribute('data-auto-generated', 'true');
            }
        });
        
        dpFieldCodeInput.addEventListener('input', function() {
            if (this.value) {
                this.removeAttribute('data-auto-generated');
            }
        });
    }

    // Dimension Management in Drawer
    const manageDimensionsBtn = document.getElementById('manageDimensionsBtn');
    if (manageDimensionsBtn) {
        manageDimensionsBtn.addEventListener('click', function() {
            const fieldName = document.getElementById('dpName').value || 'New Field';
            openDrawerDimensionModal(fieldName);
        });
    }

    // Unit Converter in Drawer
    const convertUnitsBtn = document.getElementById('convertUnitsBtn');
    if (convertUnitsBtn) {
        convertUnitsBtn.addEventListener('click', function() {
            const unitCategory = document.getElementById('dpUnitCategory').value;
            if (unitCategory) {
                openUnitConverter(unitCategory);
            } else {
                alert('Please select a unit category first');
            }
        });
    }

    // Unit category change handler in drawer
    const dpUnitCategory = document.getElementById('dpUnitCategory');
    const dpDefaultUnit = document.getElementById('dpDefaultUnit');
    
    if (dpUnitCategory && dpDefaultUnit) {
        dpUnitCategory.addEventListener('change', function() {
            loadUnitOptionsForDrawer(this.value, dpDefaultUnit);
        });
    }

    // Drawer Functions
    function openDataPointDrawer(dataPointIndex = -1) {
        editingDataPointIndex = dataPointIndex;
        
        if (dataPointIndex >= 0) {
            // Editing existing data point
            drawerTitle.textContent = 'Edit Data Point';
            populateDrawerForm(dataPoints[dataPointIndex]);
        } else {
            // Adding new data point
            drawerTitle.textContent = 'Add Data Point';
            resetDrawerForm();
        }
        
        // Update topic dropdown
        updateDrawerTopicDropdown();
        
        // Show drawer
        dataPointDrawer.classList.add('open');
        drawerOverlay.classList.add('show');
        document.body.style.overflow = 'hidden';
    }

    function closeDataPointDrawer() {
        dataPointDrawer.classList.remove('open');
        drawerOverlay.classList.remove('show');
        document.body.style.overflow = '';
        resetDrawerForm();
        editingDataPointIndex = -1;
    }

    function resetDrawerForm() {
        dataPointForm.reset();
        formulaSection.style.display = 'none';
        dpComputedCheckbox.checked = false;
        
        // Reset auto-generated attribute
        dpFieldCodeInput.removeAttribute('data-auto-generated');
        
        // Reset dimension summary
        const dimensionSummary = document.querySelector('#dataPointDrawer .dimension-summary');
        if (dimensionSummary) {
            dimensionSummary.innerHTML = '<small class="text-muted">No dimensions assigned</small>';
        }
        
        // Reset field mappings
        const fieldMappings = document.getElementById('fieldMappings');
        if (fieldMappings) {
            fieldMappings.innerHTML = '';
        }
    }

    function populateDrawerForm(dataPoint) {
        document.getElementById('dpName').value = dataPoint.name || '';
        document.getElementById('dpFieldCode').value = dataPoint.field_code || '';
        document.getElementById('dpValueType').value = dataPoint.value_type || '';
        document.getElementById('dpUnitCategory').value = dataPoint.unit_category || '';
        document.getElementById('dpDefaultUnit').value = dataPoint.default_unit || '';
        document.getElementById('dpTopic').value = dataPoint.topic_id || '';
        document.getElementById('dpDescription').value = dataPoint.description || '';
        document.getElementById('dpComputed').checked = dataPoint.is_computed || false;
        document.getElementById('dpFormula').value = dataPoint.formula || '';
        
        // Show formula section if computed
        if (dataPoint.is_computed) {
            formulaSection.style.display = 'block';
        }
        
        // Populate dimensions if any
        if (dataPoint.dimensions && dataPoint.dimensions.length > 0) {
            updateDrawerDimensionSummary(dataPoint.dimensions);
        }
    }

    function updateDrawerTopicDropdown() {
        const topicSelect = document.getElementById('dpTopic');
        topicSelect.innerHTML = '<option value="">-- Select Topic --</option>';
        
        const allTopics = topics.concat(customTopics);
        allTopics.forEach(topic => {
            addTopicOptionRecursive(topicSelect, topic, '');
        });
    }

    function updateDrawerDimensionSummary(dimensions) {
        const dimensionSummary = document.querySelector('#dataPointDrawer .dimension-summary');
        if (dimensions && dimensions.length > 0) {
            const dimensionTags = dimensions.map(dim => 
                `<span class="dimension-tag">${dim.name}</span>`
            ).join('');
            dimensionSummary.innerHTML = dimensionTags;
        } else {
            dimensionSummary.innerHTML = '<small class="text-muted">No dimensions assigned</small>';
        }
    }

    function saveDataPoint() {
        // Validate required fields
        const name = document.getElementById('dpName').value.trim();
        const valueType = document.getElementById('dpValueType').value;
        
        if (!name) {
            alert('Data point name is required');
            return;
        }
        
        if (!valueType) {
            alert('Value type is required');
            return;
        }
        
        // Create data point object
        const dataPoint = {
            name: name,
            field_code: document.getElementById('dpFieldCode').value.trim() || generateSlug(name),
            value_type: valueType,
            unit_category: document.getElementById('dpUnitCategory').value,
            default_unit: document.getElementById('dpDefaultUnit').value.trim(),
            topic_id: document.getElementById('dpTopic').value,
            description: document.getElementById('dpDescription').value.trim(),
            is_computed: document.getElementById('dpComputed').checked,
            formula: document.getElementById('dpFormula').value.trim(),
            dimensions: [], // Will be populated from dimension management
            id: editingDataPointIndex >= 0 ? dataPoints[editingDataPointIndex].id : Date.now()
        };
        
        // Update or add data point
        if (editingDataPointIndex >= 0) {
            dataPoints[editingDataPointIndex] = dataPoint;
        } else {
            dataPoints.push(dataPoint);
        }
        
        // Refresh display
        renderDataPointCards();
        closeDataPointDrawer();
    }

    function renderDataPointCards() {
        if (dataPoints.length === 0) {
            emptyState.style.display = 'block';
            return;
        }
        
        emptyState.style.display = 'none';
        
        const cardsHtml = dataPoints.map((dataPoint, index) => {
            const badges = [];
            
            if (dataPoint.value_type) {
                badges.push(`<span class="data-point-badge badge-type">${dataPoint.value_type}</span>`);
            }
            
            if (dataPoint.unit_category) {
                badges.push(`<span class="data-point-badge badge-unit">${dataPoint.unit_category}</span>`);
            }
            
            if (dataPoint.is_computed) {
                badges.push(`<span class="data-point-badge badge-computed">Computed</span>`);
            }
            
            if (dataPoint.topic_name) {
                badges.push(`<span class="data-point-badge badge-topic">${dataPoint.topic_name}</span>`);
            }
            
            return `
                <div class="data-point-card" data-index="${index}">
                    <div class="data-point-card-header">
                        <h6 class="data-point-card-title">${dataPoint.name}</h6>
                        <span class="data-point-card-code">${dataPoint.field_code}</span>
                    </div>
                    <div class="data-point-card-meta">
                        ${badges.join('')}
                </div>
                    ${dataPoint.description ? `<div class="data-point-card-description">${dataPoint.description}</div>` : ''}
                    <div class="data-point-card-actions">
                        <button type="button" class="btn btn-sm btn-outline-primary edit-data-point" data-index="${index}">
                            <i class="fas fa-edit"></i> Edit
                    </button>
                        <button type="button" class="btn btn-sm btn-outline-danger delete-data-point" data-index="${index}">
                            <i class="fas fa-trash"></i> Delete
                </button>
                    </div>
                </div>
        `;
        }).join('');

        dataPointsContainer.innerHTML = cardsHtml;
        
        // Add event listeners to cards
        addDataPointCardListeners();
    }

    function addDataPointCardListeners() {
        // Edit buttons
        document.querySelectorAll('.edit-data-point').forEach(btn => {
            btn.addEventListener('click', function(e) {
                e.stopPropagation();
                const index = parseInt(this.getAttribute('data-index'));
                openDataPointDrawer(index);
            });
        });
        
        // Delete buttons
        document.querySelectorAll('.delete-data-point').forEach(btn => {
            btn.addEventListener('click', function(e) {
                e.stopPropagation();
                const index = parseInt(this.getAttribute('data-index'));
                if (confirm('Are you sure you want to delete this data point?')) {
                    dataPoints.splice(index, 1);
                    renderDataPointCards();
                }
            });
        });
        
        // Card click to edit
        document.querySelectorAll('.data-point-card').forEach(card => {
            card.addEventListener('click', function() {
                const index = parseInt(this.getAttribute('data-index'));
                openDataPointDrawer(index);
            });
        });
    }

    // Drawer-specific helper functions
    function openDrawerDimensionModal(fieldName) {
        // Use the existing dimension modal but adapt it for drawer context
        const modal = document.getElementById('dimensionModal');
        const fieldNameSpan = document.getElementById('dimensionFieldName');
        
        if (fieldNameSpan) {
            fieldNameSpan.textContent = fieldName;
        }
        
        // Load available dimensions
        loadAvailableDimensions();
        
        // Clear assigned dimensions for new drawer context
        const assignedDimensionsContainer = document.getElementById('assignedDimensions');
        if (assignedDimensionsContainer) {
            assignedDimensionsContainer.innerHTML = '<p class="text-muted">No dimensions assigned yet</p>';
        }
        
        const bootstrapModal = new bootstrap.Modal(modal);
        bootstrapModal.show();
        
        // Override the save button to work with drawer
        const saveDimensionsBtn = document.getElementById('saveDimensions');
        if (saveDimensionsBtn) {
            saveDimensionsBtn.onclick = function() {
                saveDrawerDimensions();
                bootstrapModal.hide();
            };
        }
    }

    function saveDrawerDimensions() {
        // Get selected dimensions from the modal
        const assignedDimensions = [];
        const dimensionCards = document.querySelectorAll('#assignedDimensions .dimension-card');
        
        dimensionCards.forEach(card => {
            const dimensionId = card.getAttribute('data-dimension-id');
            const dimensionName = card.querySelector('.dimension-name')?.textContent;
            if (dimensionId && dimensionName) {
                assignedDimensions.push({
                    id: dimensionId,
                    name: dimensionName
                });
            }
        });

        // Update the drawer dimension summary
        updateDrawerDimensionSummary(assignedDimensions);
        
        // Store in hidden input
        const fieldDimensionsInput = document.getElementById('fieldDimensions');
        if (fieldDimensionsInput) {
            fieldDimensionsInput.value = JSON.stringify(assignedDimensions);
        }
    }

    function loadUnitOptionsForDrawer(unitCategory, unitInput) {
        if (!unitCategory) {
            unitInput.placeholder = 'Enter custom unit';
            return;
        }
        
        fetch(`/admin/unit_categories`)
            .then(response => response.json())
            .then(data => {
                const categoryUnits = data[unitCategory] || [];
                const datalist = document.createElement('datalist');
                datalist.id = `drawer-units-${Date.now()}`;
                
                categoryUnits.forEach(unit => {
                    const option = document.createElement('option');
                    option.value = unit;
                    datalist.appendChild(option);
                });
                
                // Remove existing datalist if any
                const existingDatalist = document.querySelector(`#${unitInput.getAttribute('list')}`);
                if (existingDatalist) {
                    existingDatalist.remove();
                }
                
                unitInput.setAttribute('list', datalist.id);
                unitInput.placeholder = `e.g., ${categoryUnits.slice(0, 3).join(', ')}`;
                document.body.appendChild(datalist);
            })
            .catch(error => console.error('Error loading unit options:', error));
    }

    function addRowEventListeners(row) {
        // Auto-generate field code
        const nameInput = row.querySelector('.field-name-input');
        const codeInput = row.querySelector('.field-code-input');
        
        nameInput.addEventListener('input', function() {
            if (!codeInput.value || codeInput.hasAttribute('data-auto-generated')) {
                const slug = generateSlug(this.value);
                codeInput.value = slug;
                codeInput.setAttribute('data-auto-generated', 'true');
            }
        });
        
        codeInput.addEventListener('input', function() {
            if (this.value) {
                this.removeAttribute('data-auto-generated');
            }
        });

        // Toggle computed field inputs
        const computedCheckbox = row.querySelector('.is-computed-checkbox');
        const formulaInputs = row.querySelector('.formula-inputs');
        
        computedCheckbox.addEventListener('change', function() {
            if (this.checked) {
                formulaInputs.classList.remove('d-none');
            } else {
                formulaInputs.classList.add('d-none');
            }
        });

        // Remove row
        const removeBtn = row.querySelector('.remove-data-point');
        removeBtn.addEventListener('click', function() {
            row.remove();
        });

        // Add raw field mapping for computed fields
        const addRawFieldBtn = row.querySelector('.add-raw-field');
        addRawFieldBtn.addEventListener('click', function() {
            addRawFieldMapping(row);
        });

        // Phase 4.1: Setup unit-aware inputs for new row
        setupUnitAwareInputs(row);
        
        // Phase 2.5: Setup dimension management for new row
        setupDimensionManagement(row);
    }

    // Phase 2.5: Dimension Management Functions
    function setupDimensionManagement(row) {
        const manageDimensionsBtn = row.querySelector('.manage-dimensions-btn');
        if (manageDimensionsBtn) {
            manageDimensionsBtn.addEventListener('click', function() {
                const rowId = this.getAttribute('data-row-id');
                const fieldNameInput = row.querySelector('.field-name-input');
                const fieldName = fieldNameInput ? fieldNameInput.value : 'New Field';
                openDimensionModal(rowId, fieldName, row);
            });
        }
    }
    
    let availableDimensions = [];
    let currentDimensionRow = null;
    
    function openDimensionModal(rowId, fieldName, row) {
        currentDimensionRow = row;
        const modal = document.getElementById('dimensionModal');
        const fieldNameSpan = document.getElementById('dimensionFieldName');
        
        if (fieldNameSpan) {
            fieldNameSpan.textContent = fieldName;
        }
        
        // Load available dimensions
        loadAvailableDimensions();
        
        // Load currently assigned dimensions for this field
        loadFieldDimensions(row);
        
        const bootstrapModal = new bootstrap.Modal(modal);
        bootstrapModal.show();
    }
    
    function loadAvailableDimensions() {
        fetch('/admin/dimensions')
            .then(response => response.json())
            .then(data => {
                availableDimensions = data.dimensions || [];
                displayAvailableDimensions();
            })
            .catch(error => {
                availableDimensions = [];
                displayAvailableDimensions();
            });
    }
    
    function displayAvailableDimensions() {
        const container = document.getElementById('availableDimensions');
        if (!container) return;
        
        if (availableDimensions.length === 0) {
            container.innerHTML = '<p class="text-muted">No dimensions available. Create one first.</p>';
            return;
        }
        
        container.innerHTML = availableDimensions.map(dim => `
            <div class="dimension-card border rounded p-2 mb-2">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <strong>${dim.name}</strong>
                        <div class="text-muted small">${dim.description || 'No description'}</div>
                        <div class="mt-1">
                            ${dim.values.map(val => `
                                <span class="badge bg-light text-dark me-1">${val.display_name || val.value}</span>
                            `).join('')}
                        </div>
                    </div>
                    <button type="button" class="btn btn-sm btn-outline-primary assign-dimension-btn" 
                            data-dimension-id="${dim.dimension_id}" data-dimension-name="${dim.name}">
                        <i class="fas fa-plus"></i> Assign
                    </button>
                </div>
            </div>
        `).join('');
        
        // Add event listeners for assign buttons
        container.querySelectorAll('.assign-dimension-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const dimensionId = this.getAttribute('data-dimension-id');
                const dimensionName = this.getAttribute('data-dimension-name');
                assignDimensionToField(dimensionId, dimensionName);
            });
        });
    }
    
    // Dimension Creation Functions
    function initializeDimensionCreation() {
        const createDimensionBtn = document.getElementById('createDimensionBtn');
        const saveDimensionBtn = document.getElementById('saveDimension');
        const addValueBtn = document.getElementById('addDimensionValue');
        
        if (createDimensionBtn) {
            createDimensionBtn.addEventListener('click', function() {
                const createModal = new bootstrap.Modal(document.getElementById('createDimensionModal'));
                resetDimensionForm();
                createModal.show();
            });
        }
        
        if (saveDimensionBtn) {
            saveDimensionBtn.addEventListener('click', createNewDimension);
        }
        
        if (addValueBtn) {
            addValueBtn.addEventListener('click', addDimensionValueRow);
        }
        
        // Initialize remove value button handlers
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('remove-value-btn') || e.target.closest('.remove-value-btn')) {
                const button = e.target.closest('.remove-value-btn');
                const row = button.closest('.input-group');
                if (document.querySelectorAll('.dimension-value-input').length > 1) {
                    row.remove();
                }
            }
        });
    }
    
    function resetDimensionForm() {
        document.getElementById('dimensionName').value = '';
        document.getElementById('dimensionDescription').value = '';
        
        // Reset dimension values to single row
        const valuesContainer = document.getElementById('dimensionValues');
        valuesContainer.innerHTML = `
            <div class="input-group mb-2">
                <input type="text" class="form-control dimension-value-input" placeholder="e.g., Male" required>
                <input type="text" class="form-control" placeholder="Display name (optional)">
                <button type="button" class="btn btn-outline-danger remove-value-btn">
                    <i class="fas fa-trash"></i>
                </button>
            </div>
        `;
    }
    
    function addDimensionValueRow() {
        const valuesContainer = document.getElementById('dimensionValues');
        const newRow = document.createElement('div');
        newRow.className = 'input-group mb-2';
        newRow.innerHTML = `
            <input type="text" class="form-control dimension-value-input" placeholder="e.g., Female" required>
            <input type="text" class="form-control" placeholder="Display name (optional)">
            <button type="button" class="btn btn-outline-danger remove-value-btn">
                <i class="fas fa-trash"></i>
            </button>
        `;
        valuesContainer.appendChild(newRow);
    }
    
    function createNewDimension() {
        const name = document.getElementById('dimensionName').value.trim();
        const description = document.getElementById('dimensionDescription').value.trim();
        
        if (!name) {
            alert('Dimension name is required');
            return;
        }
        
        // Collect dimension values
        const valueInputs = document.querySelectorAll('.dimension-value-input');
        const displayInputs = document.querySelectorAll('#dimensionValues .input-group input[type="text"]:nth-child(2)');
        
        const values = [];
        valueInputs.forEach((input, index) => {
            const value = input.value.trim();
            if (value) {
                const displayName = displayInputs[index] ? displayInputs[index].value.trim() : '';
                values.push({
                    value: value,
                    display_name: displayName || value,
                    display_order: index + 1
                });
            }
        });
        
        if (values.length === 0) {
            alert('At least one dimension value is required');
            return;
        }
        
        const dimensionData = {
            name: name,
            description: description || null,
            values: values
        };
        
        // Save dimension via API
        fetch('/admin/dimensions', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(dimensionData)
        })
        .then(response => response.json())
        .then(data => {
                // Close the modal
                const createModal = bootstrap.Modal.getInstance(document.getElementById('createDimensionModal'));
                createModal.hide();
                
                // Refresh available dimensions
                loadAvailableDimensions();
                
                alert('Dimension created successfully!');
        })
        .catch(error => {
            console.error('Error creating dimension:', error);
            alert('Error creating dimension. Please try again.');
        });
    }
    
    function loadFieldDimensions(row) {
        const dimensionsInput = row.querySelector('.field-dimensions-input');
        const assignedContainer = document.getElementById('assignedDimensions');
        
        if (!assignedContainer) return;
        
        try {
            const assignedDimensions = dimensionsInput.value ? JSON.parse(dimensionsInput.value) : [];
            displayAssignedDimensions(assignedDimensions);
        } catch (error) {
            displayAssignedDimensions([]);
        }
    }
    
    function displayAssignedDimensions(assignedDimensions) {
        const container = document.getElementById('assignedDimensions');
        if (!container) return;
        
        if (assignedDimensions.length === 0) {
            container.innerHTML = '<p class="text-muted">No dimensions assigned to this field.</p>';
            return;
        }
        
        container.innerHTML = assignedDimensions.map(dim => `
            <div class="dimension-card border rounded p-2 mb-2 bg-light">
                <div class="d-flex justify-content-between align-items-center">
                    <div>
                        <strong>${dim.name}</strong>
                        <div class="form-check mt-1">
                            <input class="form-check-input dimension-required-cb" type="checkbox" 
                                   ${dim.is_required ? 'checked' : ''} 
                                   data-dimension-id="${dim.dimension_id}">
                            <label class="form-check-label small">Required for data entry</label>
                        </div>
                    </div>
                    <button type="button" class="btn btn-sm btn-outline-danger remove-dimension-btn" 
                            data-dimension-id="${dim.dimension_id}">
                        <i class="fas fa-times"></i> Remove
                    </button>
                </div>
            </div>
        `).join('');
        
        // Add event listeners
        container.querySelectorAll('.remove-dimension-btn').forEach(btn => {
            btn.addEventListener(function() {
                const dimensionId = this.getAttribute('data-dimension-id');
                removeDimensionFromField(dimensionId);
            });
        });
        
        container.querySelectorAll('.dimension-required-cb').forEach(cb => {
            cb.addEventListener('change', function() {
                const dimensionId = this.getAttribute('data-dimension-id');
                updateDimensionRequirement(dimensionId, this.checked);
            });
        });
    }
    
    function assignDimensionToField(dimensionId, dimensionName) {
        if (!currentDimensionRow) return;
        
        const dimensionsInput = currentDimensionRow.querySelector('.field-dimensions-input');
        let assignedDimensions;
        
        try {
            assignedDimensions = dimensionsInput.value ? JSON.parse(dimensionsInput.value) : [];
        } catch (error) {
            assignedDimensions = [];
        }
        
        // Check if already assigned
        if (assignedDimensions.find(dim => dim.dimension_id === dimensionId)) {
            alert('This dimension is already assigned to the field.');
            return;
        }
        
        // Add the dimension
        assignedDimensions.push({
            dimension_id: dimensionId,
            name: dimensionName,
            is_required: false
        });
        
        // Update the hidden input
        dimensionsInput.value = JSON.stringify(assignedDimensions);
        
        // Refresh the display
        displayAssignedDimensions(assignedDimensions);
        updateDimensionSummary(currentDimensionRow, assignedDimensions);
    }
    
    function removeDimensionFromField(dimensionId) {
        if (!currentDimensionRow) return;
        
        const dimensionsInput = currentDimensionRow.querySelector('.field-dimensions-input');
        let assignedDimensions;
        
        try {
            assignedDimensions = dimensionsInput.value ? JSON.parse(dimensionsInput.value) : [];
        } catch (error) {
            assignedDimensions = [];
        }
        
        // Remove the dimension
        assignedDimensions = assignedDimensions.filter(dim => dim.dimension_id !== dimensionId);
        
        // Update the hidden input
        dimensionsInput.value = JSON.stringify(assignedDimensions);
        
        // Refresh the display
        displayAssignedDimensions(assignedDimensions);
        updateDimensionSummary(currentDimensionRow, assignedDimensions);
    }
    
    function updateDimensionRequirement(dimensionId, isRequired) {
        if (!currentDimensionRow) return;
        
        const dimensionsInput = currentDimensionRow.querySelector('.field-dimensions-input');
        let assignedDimensions;
        
        try {
            assignedDimensions = dimensionsInput.value ? JSON.parse(dimensionsInput.value) : [];
        } catch (error) {
            assignedDimensions = [];
        }
        
        // Update the requirement flag
        const dimension = assignedDimensions.find(dim => dim.dimension_id === dimensionId);
        if (dimension) {
            dimension.is_required = isRequired;
            dimensionsInput.value = JSON.stringify(assignedDimensions);
            updateDimensionSummary(currentDimensionRow, assignedDimensions);
        }
    }
    
    function updateDimensionSummary(row, assignedDimensions) {
        const summaryDiv = row.querySelector('.dimension-summary');
        if (!summaryDiv) return;
        
        if (assignedDimensions.length === 0) {
            summaryDiv.innerHTML = '<small class="text-muted">No dimensions assigned</small>';
        } else {
            const requiredCount = assignedDimensions.filter(dim => dim.is_required).length;
            summaryDiv.innerHTML = `
                <small class="text-success">
                    ${assignedDimensions.length} dimension(s) assigned
                    ${requiredCount > 0 ? `(${requiredCount} required)` : ''}
                </small>
            `;
        }
    }

    // Phase 2.5: Raw Field Mapping with Dimension Support for Computed Fields
    function addRawFieldMapping(row) {
        const rawFieldsContainer = row.querySelector('.raw-fields-container');
        if (!rawFieldsContainer) return;
        
        const mappingId = Date.now() + Math.random();
        const mappingDiv = document.createElement('div');
        mappingDiv.className = 'raw-field-mapping border rounded p-3 mb-3';
        mappingDiv.setAttribute('data-mapping-id', mappingId);
        
        mappingDiv.innerHTML = `
            <div class="row g-3">
                <div class="col-md-2">
                    <label class="form-label">Variable</label>
                    <input type="text" class="form-control form-control-sm variable-input" 
                           placeholder="A" maxlength="1" pattern="[A-Z]" required>
                </div>
                <div class="col-md-3">
                    <label class="form-label">Framework</label>
                    <select class="form-control form-control-sm framework-select" required>
                        <option value="">Select Framework</option>
                    </select>
                </div>
                <div class="col-md-4">
                    <label class="form-label">Field</label>
                    <select class="form-control form-control-sm field-select" disabled required>
                        <option value="">Select Framework First</option>
                    </select>
                </div>
                <div class="col-md-2">
                    <label class="form-label">Coefficient</label>
                    <input type="number" class="form-control form-control-sm coefficient-input" 
                           value="1" step="any" required>
                </div>
                <div class="col-md-1">
                    <label class="form-label">&nbsp;</label>
                    <button type="button" class="btn btn-danger btn-sm d-block remove-mapping-btn">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>
            
            <!-- Phase 2.5: Dimension Configuration for Computed Fields -->
            <div class="computed-field-dimension-config">
                <h6><i class="fas fa-tags"></i> Dimension Aggregation</h6>
                
                <div class="aggregation-type-selector">
                    <div class="form-check">
                        <input class="form-check-input aggregation-type-radio" type="radio" 
                               name="aggregation_type_${mappingId}" 
                               id="sum_all_${mappingId}" 
                               value="SUM_ALL_DIMENSIONS" checked>
                        <label class="form-check-label" for="sum_all_${mappingId}">
                            <strong>Sum All Dimensions</strong>
                            <small class="d-block text-muted">Aggregate all dimensional values (e.g., All Male + Female employees)</small>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input aggregation-type-radio" type="radio" 
                               name="aggregation_type_${mappingId}" 
                               id="specific_dimension_${mappingId}" 
                               value="SPECIFIC_DIMENSION">
                        <label class="form-check-label" for="specific_dimension_${mappingId}">
                            <strong>Specific Dimension Filter</strong>
                            <small class="d-block text-muted">Filter to specific dimensional values (e.g., Only Male employees under 30)</small>
                        </label>
                    </div>
                </div>
                
                <div class="dimension-filter-section" style="display: none;">
                    <div class="dimension-filter-builder">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <label class="form-label mb-0">Dimension Filters</label>
                            <button type="button" class="btn btn-outline-primary btn-sm add-dimension-filter-btn">
                                <i class="fas fa-plus"></i> Add Filter
                            </button>
                        </div>
                        <div class="dimension-filters-container">
                            <!-- Dimension filter rules will be added here -->
                        </div>
                        <small class="text-muted">
                            Only data matching all selected dimension values will be included in the calculation.
                        </small>
                    </div>
                </div>
                </div>
            `;

        rawFieldsContainer.appendChild(mappingDiv);
        
        // Setup event listeners for this mapping
        setupMappingEventListeners(mappingDiv, mappingId);
        
        // Load available frameworks
        loadFrameworksForMapping(mappingDiv);
    }
    
    function setupMappingEventListeners(mappingDiv, mappingId) {
        // Framework selection
        const frameworkSelect = mappingDiv.querySelector('.framework-select');
        const fieldSelect = mappingDiv.querySelector('.field-select');
        
            frameworkSelect.addEventListener('change', function() {
            if (this.value) {
                loadFieldsForFramework(this.value, fieldSelect);
            } else {
                fieldSelect.innerHTML = '<option value="">Select Framework First</option>';
                fieldSelect.disabled = true;
            }
        });
        
        // Remove mapping
        const removeBtn = mappingDiv.querySelector('.remove-mapping-btn');
        removeBtn.addEventListener('click', function() {
            mappingDiv.remove();
        });
        
        // Aggregation type change
        const aggregationRadios = mappingDiv.querySelectorAll('.aggregation-type-radio');
        const dimensionFilterSection = mappingDiv.querySelector('.dimension-filter-section');
        
        aggregationRadios.forEach(radio => {
            radio.addEventListener('change', function() {
                if (this.value === 'SPECIFIC_DIMENSION') {
                    dimensionFilterSection.style.display = 'block';
                    loadAvailableDimensionsForFilter(mappingDiv);
                } else {
                    dimensionFilterSection.style.display = 'none';
                }
            });
        });
        
        // Add dimension filter
        const addFilterBtn = mappingDiv.querySelector('.add-dimension-filter-btn');
        addFilterBtn.addEventListener('click', function() {
            addDimensionFilterRule(mappingDiv);
        });
    }
    
    function loadFrameworksForMapping(mappingDiv) {
        const frameworkSelect = mappingDiv.querySelector('.framework-select');
        
        fetch('/admin/frameworks/list')
            .then(response => response.json())
            .then(data => {
                frameworkSelect.innerHTML = '<option value="">Select Framework</option>';
                data.frameworks.forEach(framework => {
                    const option = document.createElement('option');
                    option.value = framework.framework_id;
                    option.textContent = framework.framework_name;
                    frameworkSelect.appendChild(option);
                });
            })
            .catch(error => {
                frameworkSelect.innerHTML = '<option value="">Error loading frameworks</option>';
            });
    }
    
    function loadFieldsForFramework(frameworkId, fieldSelect) {
        fieldSelect.innerHTML = '<option value="">Loading...</option>';
        fieldSelect.disabled = true;
        
        fetch(`/admin/get_framework_fields/${frameworkId}`)
            .then(response => response.json())
            .then(fields => {
                fieldSelect.innerHTML = '<option value="">Select Field</option>';
                fields.forEach(field => {
                    const option = document.createElement('option');
                    option.value = field.field_id;
                    option.textContent = `${field.field_name} (${field.field_code})`;
                    fieldSelect.appendChild(option);
                });
                fieldSelect.disabled = false;
            })
            .catch(error => {
                fieldSelect.innerHTML = '<option value="">Error loading fields</option>';
            });
    }
    
    function loadAvailableDimensionsForFilter(mappingDiv) {
        // Use the same availableDimensions array loaded earlier
        if (availableDimensions.length === 0) {
            loadAvailableDimensions(); // Reload if not available
        }
    }
    
    function addDimensionFilterRule(mappingDiv) {
        const filtersContainer = mappingDiv.querySelector('.dimension-filters-container');
        const ruleId = Date.now() + Math.random();
        
        const ruleDiv = document.createElement('div');
        ruleDiv.className = 'dimension-filter-rule';
        ruleDiv.setAttribute('data-rule-id', ruleId);
        
        ruleDiv.innerHTML = `
            <select class="form-select dimension-select" required>
                <option value="">Select Dimension</option>
                ${availableDimensions.map(dim => 
                    `<option value="${dim.dimension_id}">${dim.name}</option>`
                ).join('')}
            </select>
            <select class="form-select dimension-value-select" disabled required>
                <option value="">Select Dimension First</option>
            </select>
            <button type="button" class="btn btn-outline-danger btn-sm remove-filter-btn">
                <i class="fas fa-times"></i>
            </button>
        `;
        
        filtersContainer.appendChild(ruleDiv);
        
        // Setup event listeners for this rule
        const dimensionSelect = ruleDiv.querySelector('.dimension-select');
        const valueSelect = ruleDiv.querySelector('.dimension-value-select');
        const removeBtn = ruleDiv.querySelector('.remove-filter-btn');
        
        dimensionSelect.addEventListener('change', function() {
            if (this.value) {
                const dimension = availableDimensions.find(dim => dim.dimension_id === this.value);
                if (dimension) {
                    valueSelect.innerHTML = '<option value="">Select Value</option>';
                    dimension.values.forEach(value => {
                        const option = document.createElement('option');
                        option.value = value.value;
                        option.textContent = value.effective_display_name || value.display_name || value.value;
                        valueSelect.appendChild(option);
                    });
                    valueSelect.disabled = false;
                }
            } else {
                valueSelect.innerHTML = '<option value="">Select Dimension First</option>';
                valueSelect.disabled = true;
            }
        });
        
        removeBtn.addEventListener('click', function() {
            ruleDiv.remove();
        });
    }

    // Phase 3: Enhanced dependency tracking
    function checkFieldDependencies(fieldId) {
        if (!fieldId) return;
        
        fetch(`/admin/fields/${fieldId}/dependants`)
            .then(response => response.json())
            .then(data => {
                const dependencyInfo = document.querySelector(`[data-field-id="${fieldId}"] .dependency-info`);
                if (dependencyInfo) {
                    if (data.dependant_count > 0) {
                        dependencyInfo.innerHTML = `
                            <span class="badge bg-warning" title="This field has dependants">
                                🔗 ${data.dependant_count} dependant(s)
                            </span>
                        `;
                        dependencyInfo.addEventListener('click', () => showDependantsModal(data));
                    } else {
                        dependencyInfo.innerHTML = '';
                    }
                }
            })
            .catch(error => console.error('Error checking dependencies:', error));
    }

    function showDependantsModal(dependencyData) {
        const modalContent = `
            <div class="modal fade" id="dependantsModal" tabindex="-1">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">Fields Depending on: ${dependencyData.field_name}</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <p><strong>Dependant Count:</strong> ${dependencyData.dependant_count}</p>
                            <div class="list-group">
                                ${dependencyData.dependants.map(dep => `
                                    <div class="list-group-item">
                                        <strong>${dep.field_name}</strong> (${dep.field_code})
                                        <br><small class="text-muted">Framework: ${dep.framework_name}</small>
                                        <br><small class="text-info">Formula: ${dep.formula_expression}</small>
                                        ${dep.topic_name ? `<br><small class="text-secondary">Topic: ${dep.topic_name}</small>` : ''}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Remove existing modal if any
        const existingModal = document.getElementById('dependantsModal');
        if (existingModal) {
            existingModal.remove();
        }
        
        // Add new modal
        document.body.insertAdjacentHTML('beforeend', modalContent);
        const modal = new bootstrap.Modal(document.getElementById('dependantsModal'));
        modal.show();
        
        // Clean up when modal is hidden
        document.getElementById('dependantsModal').addEventListener('hidden.bs.modal', function() {
            this.remove();
        });
    }

    // Event delegation for topic and dependency management
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('delete-topic')) {
            const topicId = e.target.getAttribute('data-topic-id');
            if (confirm('Are you sure you want to delete this topic?')) {
                deleteTopic(topicId);
            }
        }
        
        if (e.target.closest('.dependency-info')) {
            const fieldId = e.target.closest('[data-field-id]')?.getAttribute('data-field-id');
            if (fieldId) {
                checkFieldDependencies(fieldId);
            }
        }
    });

    function deleteTopic(topicId) {
        fetch(`/admin/topics/${topicId}`, {
            method: 'DELETE'
        })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                alert('Error: ' + data.error);
            } else {
                loadFrameworkTopics(currentFrameworkId);
                loadCustomTopics();
            }
        })
        .catch(error => {
            alert('Error deleting topic');
        });
    }

    // OLD Framework Details Modal handler - REMOVED
    // This has been replaced by the enhanced coverage dashboard version below

    // Note: Form validation is handled in the main submit event listener above

    // Phase 4.1: Unit-aware input widgets
    function setupUnitAwareInputs(row) {
        const unitCategorySelect = row.querySelector('select[name="unit_category[]"]');
        const defaultUnitInput = row.querySelector('input[name="default_unit[]"]');
        
        if (unitCategorySelect && defaultUnitInput) {
            unitCategorySelect.addEventListener('change', function() {
                loadUnitOptions(this.value, defaultUnitInput);
            });
            
            // Add unit converter button next to unit input
            const unitContainer = defaultUnitInput.parentElement;
            const convertBtn = document.createElement('button');
            convertBtn.type = 'button';
            convertBtn.className = 'btn btn-sm btn-outline-info mt-1';
            convertBtn.innerHTML = '<i class="fas fa-exchange-alt"></i> Convert';
            convertBtn.addEventListener('click', () => openUnitConverter(unitCategorySelect.value));
            unitContainer.appendChild(convertBtn);
        }
    }

    function loadUnitOptions(unitCategory, unitInput) {
        if (!unitCategory) {
            unitInput.placeholder = 'Enter custom unit';
            return;
        }
        
        fetch(`/admin/unit_categories`)
            .then(response => response.json())
            .then(data => {
                const categoryUnits = data[unitCategory] || [];
                const datalist = document.createElement('datalist');
                datalist.id = `units-${Date.now()}`;
                
                categoryUnits.forEach(unit => {
                    const option = document.createElement('option');
                    option.value = unit;
                    datalist.appendChild(option);
                });
                
                unitInput.setAttribute('list', datalist.id);
                unitInput.placeholder = `e.g., ${categoryUnits.slice(0, 3).join(', ')}`;
                document.body.appendChild(datalist);
            })
            .catch(error => console.error('Error loading unit options:', error));
    }

    // Phase 4.1: Unit Converter Modal
    function openUnitConverter(unitCategory) {
        const modal = new bootstrap.Modal(document.getElementById('unitConverterModal'));
        
        if (unitCategory) {
            loadUnitsForConverter(unitCategory);
        }
        
        modal.show();
    }

    function loadUnitsForConverter(unitCategory) {
        fetch(`/admin/unit_categories`)
            .then(response => response.json())
            .then(data => {
                const units = data[unitCategory] || [];
                const fromUnitSelect = document.getElementById('fromUnit');
                const toUnitSelect = document.getElementById('toUnit');
                
                // Clear existing options
                fromUnitSelect.innerHTML = '<option value="">Select unit</option>';
                toUnitSelect.innerHTML = '<option value="">Select unit</option>';
                
                units.forEach(unit => {
                    const fromOption = new Option(unit, unit);
                    const toOption = new Option(unit, unit);
                    fromUnitSelect.appendChild(fromOption);
                    toUnitSelect.appendChild(toOption);
                });
            })
            .catch(error => console.error('Error loading units for converter:', error));
    }

    // Template import helpers removed – dashboard no longer has template import UI

    // Quick Actions Panel removed - no longer needed

    // Recent Activity Feed
    function loadRecentActivity() {
        fetch('/admin/frameworks/recent_activity')
            .then(response => response.json())
            .then(data => {
                const activityList = document.getElementById('recentActivityList');
                if (activityList) {
                    activityList.innerHTML = ''; // Clear existing
                    if (data.success && data.activities.length > 0) {
                        data.activities.forEach(activity => {
                            const listItem = document.createElement('li');
                            listItem.className = 'list-group-item';
                            const activityDate = new Date(activity.date).toLocaleString();
                            listItem.innerHTML = `<strong>${activity.type}:</strong> ${activity.name} <span class="text-muted float-end">${activityDate}</span>`;
                            activityList.appendChild(listItem);
                });
                    } else {
                        activityList.innerHTML = '<li class="list-group-item text-muted">No recent activity to display.</li>';
                    }
                }
            })
            .catch(error => console.error('Error loading recent activity:', error));
    }

    // Call to load recent activity on page load
    loadRecentActivity();

    // Call to load recent activity on page load
    // Recent Activity section removed - no longer needed

    function previewTemplate(templateKey) {
        fetch(`/admin/import_templates/${templateKey}/preview`)
            .then(response => response.json())
            .then(data => {
                if (!data.success || !data.preview) {
                    throw new Error('Failed to load template preview');
                }
                
                const preview = data.preview;
                
                // Switch to preview step
                document.getElementById('templateSelectionStep').classList.add('d-none');
                document.getElementById('templatePreviewStep').classList.remove('d-none');
                
                // Update buttons
                document.getElementById('previewTemplateBtn').style.display = 'none';
                document.getElementById('backToTemplatesBtn').style.display = 'inline-block';
                document.getElementById('confirmImportBtn').style.display = 'inline-block';
                
                // Store template key for import
                document.getElementById('confirmImportBtn').setAttribute('data-template-key', templateKey);
                
                // Set template name
                document.getElementById('templateFrameworkName').value = preview.template_name;
                
                // Update summary
                const summary = document.getElementById('importSummary');
                summary.innerHTML = `
                    <div class="small">
                        <div><strong>New Fields:</strong> ${preview.new_field_count}</div>
                        <div><strong>Duplicate Fields:</strong> ${preview.duplicate_field_count}</div>
                        <div><strong>Total Fields:</strong> ${preview.total_template_fields}</div>
                    </div>
                `;
                
                // Update badges
                document.getElementById('newFieldsBadge').textContent = preview.new_field_count;
                document.getElementById('duplicateFieldsBadge').textContent = preview.duplicate_field_count;
                
                // Populate new fields
                const newFieldsList = document.getElementById('newFieldsList');
                newFieldsList.innerHTML = '';
                preview.new_fields.forEach(field => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td><input type="checkbox" class="field-select" data-field-code="${field.field_code}" checked></td>
                        <td>${field.field_name}</td>
                        <td><code>${field.field_code}</code></td>
                        <td>${field.topic_path || 'Uncategorised'}</td>
                        <td>${field.default_unit || '-'}</td>
                        <td><span class="badge bg-secondary">${field.value_type}</span></td>
                    `;
                    newFieldsList.appendChild(row);
                });
                
                // Populate duplicates
                const duplicatesList = document.getElementById('duplicateFieldsList');
                duplicatesList.innerHTML = '';
                preview.duplicate_fields.forEach(field => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${field.field_name}</td>
                        <td><code>${field.field_code}</code></td>
                        <td>${field.topic_path || 'Uncategorised'}</td>
                        <td><span class="badge bg-warning">Already exists</span></td>
                    `;
                    duplicatesList.appendChild(row);
                });
            })
            .catch(error => {
                alert('Error loading template preview');
            });
    }

    // Template import modal navigation
    document.getElementById('backToTemplatesBtn').addEventListener('click', function() {
        document.getElementById('templatePreviewStep').classList.add('d-none');
        document.getElementById('templateSelectionStep').classList.remove('d-none');
        
        // Reset buttons
        this.style.display = 'none';
        document.getElementById('confirmImportBtn').style.display = 'none';
        document.getElementById('previewTemplateBtn').style.display = 'inline-block';
    });

    // Confirm template import
    document.getElementById('confirmImportBtn').addEventListener('click', function() {
        const templateKey = this.getAttribute('data-template-key');
        const frameworkName = document.getElementById('templateFrameworkName').value;
        
        // Get selected fields
        const selectedFields = Array.from(document.querySelectorAll('.field-select:checked'))
            .map(cb => cb.getAttribute('data-field-code'));
        
        if (!frameworkName.trim()) {
            alert('Please enter a framework name');
            return;
        }
        
        // Show loading state
        this.disabled = true;
        this.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Importing...';
        
        fetch(`/admin/import_templates/${templateKey}/import`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                framework_name: frameworkName,
                selected_field_codes: selectedFields
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                alert(`Framework "${frameworkName}" imported successfully with ${data.imported_field_count} fields!`);
                bootstrap.Modal.getInstance(document.getElementById('templateImportModal')).hide();
                location.reload(); // Refresh to show new framework
            } else {
                alert('Import failed: ' + (data.error || 'Unknown error'));
            }
        })
        .catch(error => {
            alert('Import failed: ' + error.message);
        })
        .finally(() => {
            this.disabled = false;
            this.innerHTML = '<i class="fas fa-download"></i> Import Framework';
        });
    });

    // Select all new fields toggle
    document.getElementById('selectAllNewFields').addEventListener('change', function() {
        document.querySelectorAll('.field-select').forEach(cb => {
            cb.checked = this.checked;
        });
    });

    // Unit Converter functionality
    document.getElementById('convertUnitsBtn').addEventListener('click', function() {
        const fromValue = parseFloat(document.getElementById('fromValue').value);
        const fromUnit = document.getElementById('fromUnit').value;
        const toUnit = document.getElementById('toUnit').value;
        const resultDiv = document.getElementById('conversionResult');
        
        if (!fromValue || !fromUnit || !toUnit) {
            resultDiv.innerHTML = '<div class="alert alert-warning">Please fill all fields</div>';
            return;
        }
        
        fetch('/admin/convert_unit', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                value: fromValue,
                from_unit: fromUnit,
                to_unit: toUnit
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                document.getElementById('toValue').value = data.converted_value;
                resultDiv.innerHTML = `
                    <div class="alert alert-success">
                        <strong>${fromValue} ${fromUnit} = ${data.converted_value} ${toUnit}</strong>
                        ${data.conversion_factor ? `<br><small>Conversion factor: ${data.conversion_factor}</small>` : ''}
                    </div>
                `;
            } else {
                resultDiv.innerHTML = `<div class="alert alert-danger">${data.error}</div>`;
            }
        })
        .catch(error => {
            resultDiv.innerHTML = '<div class="alert alert-danger">Conversion failed</div>';
        });
    });

    // Initialize framework cards and load coverage data
    function initializeFrameworkCards() {
        const frameworkCards = document.querySelectorAll('.framework-card');
        
        frameworkCards.forEach((card, index) => {
            const frameworkId = card.getAttribute('data-framework-id');
            if (frameworkId) {
                loadFrameworkCoverage(frameworkId, card);
            }
        });
        // Removed filterAndSortFrameworks call to prevent lexical declaration error
    }

    // Phase 4.3: Coverage Dashboard functionality
    function loadFrameworkCoverage(frameworkId, cardElement) {
    fetch(`/admin/frameworks/coverage/${frameworkId}`, { credentials: 'include' })
                .then(response => {
                    if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
            .then(data => {
                updateCoverageDisplay(cardElement, data);
                // Removed filterAndSortFrameworks call to prevent lexical declaration error
            })
            .catch(error => {
                const coverageText = cardElement.querySelector('.coverage-text');
                if (coverageText) {
                    coverageText.textContent = 'Coverage data unavailable';
                }
            });
    }

    function updateCoverageDisplay(cardElement, coverageData) {
        const progressBar = cardElement.querySelector('.coverage-progress');
        const coverageText = cardElement.querySelector('.coverage-text');
        
        if (progressBar && coverageText) {
            const percentage = coverageData.coverage_percentage || 0;
            
            // Update progress bar
            progressBar.style.width = `${percentage}%`;
            progressBar.setAttribute('aria-valuenow', percentage);
            
            // Update coverage class based on percentage
            progressBar.className = 'progress-bar';
            if (percentage >= 80) {
                progressBar.classList.add('bg-success');
            } else if (percentage >= 50) {
                progressBar.classList.add('bg-warning');
            } else {
                progressBar.classList.add('bg-danger');
            }
            
            // Update text
            const fieldsWithData = coverageData.fields_with_data || 0;
            const totalFields = coverageData.total_fields || 0;
            const lastUpdate = coverageData.last_updated ? new Date(coverageData.last_updated).toLocaleDateString() : 'Never';
            
            coverageText.innerHTML = `
                ${fieldsWithData}/${totalFields} fields (${percentage.toFixed(1)}%)
                <br><span class="text-muted">Last update: ${lastUpdate}</span>
            `;
        }
    }

    // Enhanced framework details modal with coverage information
    function loadFrameworkDetails(frameworkId) {
    
    const detailsUrl = `/admin/frameworks/${frameworkId}/details`;
    const coverageUrl = `/admin/frameworks/coverage/${frameworkId}`;
    
        Promise.all([
        fetch(detailsUrl, { credentials: 'include' }).then(r => {
            return r.text().then(text => {
                try {
                    return JSON.parse(text);
                } catch (e) {
                    throw new Error('Invalid JSON response for details');
                }
            });
        }),
        fetch(coverageUrl, { credentials: 'include' }).then(r => {
            return r.text().then(text => {
                try {
                    return JSON.parse(text);
                } catch (e) {
                    throw new Error('Invalid JSON response for coverage');
                }
            });
        })
        ])
        .then(([detailsResponse, coverageResponse]) => {
            
            if (detailsResponse.success && coverageResponse.success) {
                const details = detailsResponse;
                const coverage = coverageResponse;
            displayFrameworkDetailsWithCoverage(details, coverage);
            } else {
                document.getElementById('frameworkModalBody').innerHTML = 
                    '<div class="alert alert-danger">Error loading framework details: ' + 
                    (detailsResponse.error || coverageResponse.error) + '</div>';
            }
        })
        .catch(error => {
            document.getElementById('frameworkModalBody').innerHTML = 
            '<div class="alert alert-danger">Error loading framework details: ' + error.message + '</div>';
        });
    }

    function displayFrameworkDetailsWithCoverage(details, coverage) {
    
                    const modalTitle = document.getElementById('frameworkModalTitle');
                    const modalBody = document.getElementById('frameworkModalBody');

        modalTitle.textContent = details.framework_name;
        
        // Create coverage summary
        const coveragePercentage = coverage.coverage_percentage || 0;
        const fieldsWithData = coverage.fields_with_data || 0;
        const totalFields = coverage.total_fields || 0;
        
                    modalBody.innerHTML = `
            <div class="row">
                <div class="col-md-8">
                    <h6>Description</h6>
                    <p class="text-muted">${details.description || 'No description provided.'}</p>
                    
                    <h6>Framework Statistics</h6>
                    <div class="row">
                        <div class="col-md-6">
                            <div class="stat-card p-3 bg-light rounded mb-3">
                                <h5 class="text-primary">${details.total_fields || 0}</h5>
                                <small class="text-muted">Total Fields</small>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="stat-card p-3 bg-light rounded mb-3">
                                <h5 class="text-info">${details.computed_fields || 0}</h5>
                                <small class="text-muted">Computed Fields</small>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="coverage-dashboard p-3 bg-light rounded">
                        <h6 class="mb-3">Data Coverage</h6>
                        <div class="text-center mb-3">
                            <div class="coverage-circle" style="background: conic-gradient(var(--bs-success) ${coveragePercentage * 3.6}deg, var(--bs-light) 0deg); width: 80px; height: 80px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto;">
                                <div style="background: white; width: 60px; height: 60px; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                                    <strong>${coveragePercentage.toFixed(0)}%</strong>
                                </div>
                            </div>
                        </div>
                        <div class="coverage-details">
                            <div class="d-flex justify-content-between mb-2">
                                <span>Fields with data:</span>
                                <strong>${fieldsWithData}</strong>
                            </div>
                            <div class="d-flex justify-content-between mb-2">
                                <span>Total fields:</span>
                                <strong>${totalFields}</strong>
                            </div>
                            <div class="d-flex justify-content-between mb-2">
                                <span>Missing data:</span>
                                <strong class="text-danger">${totalFields - fieldsWithData}</strong>
                            </div>
                            <hr>
                            <small class="text-muted">
                                Last updated: ${coverage.last_updated ? new Date(coverage.last_updated).toLocaleString() : 'Never'}
                            </small>
                        </div>
                    </div>
                </div>
            </div>
            
            ${details.data_points && details.data_points.length > 0 ? `
            <div class="mt-4">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h6>Data Points</h6>
                    <div class="btn-group btn-group-sm" role="group">
                        <input type="radio" class="btn-check" name="fieldFilter" id="allFields" autocomplete="off" checked>
                        <label class="btn btn-outline-secondary" for="allFields">All</label>
                        
                        <input type="radio" class="btn-check" name="fieldFilter" id="withDataFields" autocomplete="off">
                        <label class="btn btn-outline-success" for="withDataFields">With Data</label>
                        
                        <input type="radio" class="btn-check" name="fieldFilter" id="missingDataFields" autocomplete="off">
                        <label class="btn btn-outline-danger" for="missingDataFields">Missing Data</label>
                    </div>
                </div>
                <div class="table-responsive">
                    <table class="table table-sm">
                                <thead>
                                    <tr>
                                <th>Field Name</th>
                                <th>Code</th>
                                        <th>Type</th>
                                <th>Unit</th>
                                <th>Data Status</th>
                                <th>Last Value</th>
                                    </tr>
                                </thead>
                        <tbody id="modalFieldsList">
                            ${details.data_points.map(field => `
                                <tr class="field-row" data-has-data="${field.has_data ? 'true' : 'false'}">
                                    <td>
                                        ${field.field_name}
                                        ${field.topic_name ? `<br><small class="text-muted">${field.topic_name}</small>` : ''}
                                    </td>
                                    <td><code>${field.field_code}</code></td>
                                    <td><span class="badge bg-secondary">${field.value_type}</span></td>
                                    <td>${field.default_unit || '-'}</td>
                                    <td>
                                        ${field.has_data ? 
                                            '<span class="badge bg-success">Has Data</span>' : 
                                            '<span class="badge bg-warning">No Data</span>'
                                        }
                                    </td>
                                    <td>
                                        ${field.last_value !== null ? 
                                            `<span class="text-success">${field.last_value}</span>` : 
                                            '<span class="text-muted">-</span>'
                                        }
                                    </td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                    </table>
                </div>
            </div>
            ` : ''}
        `;
        
        // Add field filtering functionality
        const filterButtons = document.querySelectorAll('input[name="fieldFilter"]');
        filterButtons.forEach(button => {
            button.addEventListener('change', function() {
                filterFieldsByDataStatus(this.id);
                });
        });
    }

    function filterFieldsByDataStatus(filterId) {
        const rows = document.querySelectorAll('#modalFieldsList .field-row');
        
        rows.forEach(row => {
            const hasData = row.getAttribute('data-has-data') === 'true';
            let shouldShow = true;
            
            switch(filterId) {
                case 'withDataFields':
                    shouldShow = hasData;
                    break;
                case 'missingDataFields':
                    shouldShow = !hasData;
                    break;
                case 'allFields':
                default:
                    shouldShow = true;
                    break;
            }
            
            row.style.display = shouldShow ? '' : 'none';
        });
    }

    // Initialize coverage and other page features
    (function initFrameworkPage() {
        // Existing initialization code
        const addDataPointBtn = document.getElementById('addDataPoint');
        const dataPointsContainer = document.getElementById('dataPointsContainer');
        const createFrameworkForm = document.getElementById('createFrameworkForm');
        const addTopicBtn = document.getElementById('addTopicBtn');
        
        // Initialize coverage dashboard
        initializeFrameworkCards();
        
        // Initialize dimension creation functionality
        initializeDimensionCreation();
        
        // Enhanced view details functionality with coverage
        document.querySelectorAll('.view-details-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const frameworkCard = this.closest('.framework-card');
                const frameworkId = frameworkCard.getAttribute('data-framework-id');
                if (frameworkId) {
                    loadFrameworkDetails(frameworkId);
                }
        });
    });

        // Rest of existing initialization code...
        if (addTopicBtn) {
            addTopicBtn.addEventListener('click', function() {
                const modal = new bootstrap.Modal(document.getElementById('topicModal'));
                modal.show();
            });
        }

        // Legacy table-based data point creation removed - using unified DataPoints module

        // Rest of existing event listeners...
    
    // Delegated listener so newly added/re-rendered cards still work
    const frameworkCardDeck = document.getElementById('frameworkCardDeck');
    
    // Debug: Check all framework cards on the page
    const allFrameworkCards = document.querySelectorAll('.framework-card');
    allFrameworkCards.forEach((card, index) => {
        const frameworkId = card.getAttribute('data-framework-id');
        console.log(`🔍 DEBUG: Card ${index}: ID=${frameworkId}`, card);
    });
    
    // Debug: Check all view details buttons
    const allViewDetailsButtons = document.querySelectorAll('.view-details-btn');
    
    if (frameworkCardDeck) {
        frameworkCardDeck.addEventListener('click', function(e) {
            // Handle view details button clicks
            const viewBtn = e.target.closest('.view-details-btn');
            if (viewBtn) {
                const frameworkCard = viewBtn.closest('.framework-card');
                if (frameworkCard) {
                    const frameworkId = frameworkCard.getAttribute('data-framework-id');
                    if (frameworkId) {
                        // Ensure modal is shown
                        const modalEl = document.getElementById('frameworkDetailsModal');
                        if (modalEl) {
                            const bsModal = bootstrap.Modal.getOrCreateInstance(modalEl);
                            bsModal.show();
                        }
                        loadFrameworkDetails(frameworkId);
                    }
                }
                return;
            }
            
            // Handle edit button clicks
            const editBtn = e.target.closest('.edit-framework-btn');
            if (editBtn) {
                const frameworkId = editBtn.getAttribute('data-framework-id');
                if (frameworkId) {
                    editFramework(frameworkId);
                }
                return;
            }
        });
    }
    })();

// Framework Search and Sort functionality
const frameworkSearch = document.getElementById('frameworkSearch');
const frameworkSort = document.getElementById('frameworkSort');

if (frameworkSearch) {
    frameworkSearch.addEventListener('input', filterAndSortFrameworks);
}
if (frameworkSort) {
    frameworkSort.addEventListener('change', filterAndSortFrameworks);
}

// Phase 3: Framework Type Filtering
const filterAll = document.getElementById('filterAll');
const filterGlobal = document.getElementById('filterGlobal');
const filterCompany = document.getElementById('filterCompany');
let currentTypeFilter = 'all';

if (filterAll) {
    filterAll.addEventListener('click', function() {
        currentTypeFilter = 'all';
        updateFilterButtons();
        filterAndSortFrameworks();
    });
}

if (filterGlobal) {
    filterGlobal.addEventListener('click', function() {
        currentTypeFilter = 'global';
        updateFilterButtons();
        filterAndSortFrameworks();
    });
}

if (filterCompany) {
    filterCompany.addEventListener('click', function() {
        currentTypeFilter = 'company';
        updateFilterButtons();
        filterAndSortFrameworks();
    });
}

function updateFilterButtons() {
    // Remove active class from all filter buttons
    [filterAll, filterGlobal, filterCompany].forEach(btn => {
        if (btn) btn.classList.remove('active');
    });
    
    // Add active class to current filter
    switch (currentTypeFilter) {
        case 'all':
            if (filterAll) filterAll.classList.add('active');
            break;
        case 'global':
            if (filterGlobal) filterGlobal.classList.add('active');
            break;
        case 'company':
            if (filterCompany) filterCompany.classList.add('active');
            break;
    }
}

// Added: Implement missing filterAndSortFrameworks utility to prevent runtime errors
function filterAndSortFrameworks() {
    // Ensure required DOM elements are available
    const deck = document.getElementById('frameworkCardDeck');
    if (!deck) return;

    // Use document.getElementById directly to avoid lexical declaration issues
    const searchElement = document.getElementById('frameworkSearch');
    const sortElement = document.getElementById('frameworkSort');
    
    const searchTerm = (searchElement && searchElement.value) ? searchElement.value.trim().toLowerCase() : '';
    const sortValue = sortElement ? sortElement.value : 'name_asc';

    // Collect all cards
    const allCards = Array.from(deck.querySelectorAll('.framework-card'));

    // Helper to determine if a card should be visible based on current filters
    const isVisible = (card) => {
        // Type filter (global / company) - use default 'all' if currentTypeFilter not yet initialized
        const typeFilter = (typeof currentTypeFilter !== 'undefined') ? currentTypeFilter : 'all';
        const isGlobal = card.getAttribute('data-is-global') === 'true';
        if (typeFilter === 'global' && !isGlobal) return false;
        if (typeFilter === 'company' && isGlobal) return false;

        // Search filter (name / description)
        if (searchTerm) {
            const name = card.querySelector('.card-title')?.textContent.toLowerCase() || '';
            const description = card.querySelector('.card-text')?.textContent.toLowerCase() || '';
            if (!name.includes(searchTerm) && !description.includes(searchTerm)) return false;
        }
        return true;
    };

    // Apply visibility filter first
    const visibleCards = allCards.filter(card => {
        const show = isVisible(card);
        card.style.display = show ? '' : 'none';
        return show;
    });

    // Sorting helpers
    const getCoverage = (card) => {
        const text = card.querySelector('.coverage-text')?.textContent || '';
        const match = text.match(/([0-9]+\.?[0-9]*)%/);
        return match ? parseFloat(match[1]) : 0;
    };
    const compareNames = (a, b) => a.localeCompare(b);

    // Sort the visible cards based on selected criteria
    visibleCards.sort((a, b) => {
        switch (sortValue) {
            case 'name_asc':
                return compareNames(a.querySelector('.card-title').textContent, b.querySelector('.card-title').textContent);
            case 'name_desc':
                return compareNames(b.querySelector('.card-title').textContent, a.querySelector('.card-title').textContent);
            case 'coverage_asc':
                return getCoverage(a) - getCoverage(b);
            case 'coverage_desc':
                return getCoverage(b) - getCoverage(a);
            case 'type_asc':
                return (a.getAttribute('data-is-global') === b.getAttribute('data-is-global')) ?
                    compareNames(a.querySelector('.card-title').textContent, b.querySelector('.card-title').textContent) :
                    (a.getAttribute('data-is-global') === 'true' ? -1 : 1);
            case 'type_desc':
                return (a.getAttribute('data-is-global') === b.getAttribute('data-is-global')) ?
                    compareNames(a.querySelector('.card-title').textContent, b.querySelector('.card-title').textContent) :
                    (a.getAttribute('data-is-global') === 'true' ? 1 : -1);
            default:
                return 0;
        }
    });

    // Re-append cards in the new order so the visual layout reflects the sort
    visibleCards.forEach(card => deck.appendChild(card));

    // If table view is active, refresh it to reflect the new ordering/visibility
    const tableView = document.getElementById('frameworkTableView');
    if (tableView && tableView.style.display !== 'none') {
        renderFrameworkTable();
    }
}

// View Toggle (Card vs. Table) - Initialize with a slight delay to ensure DOM is ready
setTimeout(() => {
    const cardViewBtn = document.getElementById('cardViewBtn');
    const tableViewBtn = document.getElementById('tableViewBtn');
    const frameworkCardView = document.getElementById('frameworkCardView');
    const frameworkTableView = document.getElementById('frameworkTableView');

    if (cardViewBtn && tableViewBtn && frameworkCardView && frameworkTableView) {
        cardViewBtn.addEventListener('click', () => {
            cardViewBtn.classList.add('active');
            tableViewBtn.classList.remove('active');
            frameworkCardView.style.display = '';
            frameworkTableView.style.display = 'none';
        });

        tableViewBtn.addEventListener('click', () => {
            tableViewBtn.classList.add('active');
            cardViewBtn.classList.remove('active');
            frameworkCardView.style.display = 'none';
            frameworkTableView.style.display = '';
            renderFrameworkTable();
        });
    }
}, 100);

function renderFrameworkTable() {
    // Get required elements dynamically
    const frameworkTableBody = document.getElementById('frameworkTableBody');
    const noFrameworksTable = document.getElementById('noFrameworksTable');
    
    // Check if required elements exist
    if (!frameworkTableBody || !noFrameworksTable) {
        console.error('Required table elements not found');
        return;
    }
    
    // Get all framework cards (which contain the data)
    const frameworkCards = Array.from(document.querySelectorAll('.framework-card'));
    frameworkTableBody.innerHTML = ''; // Clear existing rows

    if (frameworkCards.length === 0) {
        noFrameworksTable.style.display = 'block';
        return;
    }
    noFrameworksTable.style.display = 'none';

    frameworkCards.forEach(card => {
        const frameworkId = card.getAttribute('data-framework-id');
        const frameworkName = card.querySelector('.card-title')?.textContent || 'Unknown';
        const description = card.querySelector('.card-text')?.textContent || 'No description';
        const coverageText = card.querySelector('.coverage-text')?.textContent || '0% (0 fields)';
        const totalFields = coverageText.split('/')[1] ? parseInt(coverageText.split('/')[1].split(' ')[0]) : 'N/A';
        const lastUpdated = coverageText.includes('Last update:') ? coverageText.split('Last update:')[1].trim() : 'Never';
        
        // Get framework type information
        const isGlobal = card.getAttribute('data-is-global') === 'true';
        const isEditable = card.getAttribute('data-is-editable') === 'true';
        const frameworkType = isGlobal ? 'Global' : 'Company';
        const typeClass = isGlobal ? 'global' : 'company';
        const buttonClass = isGlobal ? 'info' : 'success';

        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${frameworkName}</td>
            <td><span class="framework-type-cell ${typeClass}">${frameworkType}</span></td>
            <td>${description}</td>
            <td>${coverageText.split('(')[0].trim()}</td>
            <td>${totalFields}</td>
            <td>${lastUpdated}</td>
            <td>
                <button class="btn btn-sm btn-outline-${buttonClass} view-details-btn" data-bs-toggle="modal" data-bs-target="#frameworkDetailsModal" data-framework-id="${frameworkId}">
                    View Details
                </button>
                ${!isGlobal ? `
                <button class="btn btn-sm btn-outline-primary ms-1 edit-framework-btn" data-framework-id="${frameworkId}" title="Edit Framework">
                    <i class="fas fa-edit"></i>
                </button>
                ` : ''}
            </td>
        `;
        frameworkTableBody.appendChild(row);
    });

    // Re-attach event listeners for view details buttons in table
    frameworkTableBody.querySelectorAll('.view-details-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const frameworkId = this.getAttribute('data-framework-id');
            loadFrameworkDetails(frameworkId);
        });
    });
    
    // Re-attach event listeners for edit buttons in table
    frameworkTableBody.querySelectorAll('.edit-framework-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const frameworkId = this.getAttribute('data-framework-id');
            editFramework(frameworkId);
        });
    });
}

    // Phase 3: Permission-based Action Handling
    function handleFrameworkPermissions() {
        const frameworkCards = document.querySelectorAll('.framework-card');
        
        frameworkCards.forEach(card => {
            const isGlobal = card.getAttribute('data-is-global') === 'true';
            const isEditable = card.getAttribute('data-is-editable') === 'true';
            
            // If it's a global framework and not editable by current user
            if (isGlobal && !isEditable) {
                // Add read-only styling if not already present
                if (!card.classList.contains('read-only')) {
                    card.classList.add('read-only');
                }
                
                // Disable any edit/delete buttons (if they exist in the future)
                const editButtons = card.querySelectorAll('.btn-edit, .btn-delete, .edit-framework-btn, .delete-framework-btn');
                editButtons.forEach(btn => {
                    btn.disabled = true;
                    btn.classList.add('disabled');
                    btn.title = 'Global frameworks can only be edited by their owners';
                });
                
                // Add tooltip to the card
                card.title = 'This is a global framework - read-only access';
            }
        });
    }

    // Initialize permission handling
    handleFrameworkPermissions();
    
    // Framework edit function
    function editFramework(frameworkId) {
        // Redirect to framework wizard in edit mode
        window.location.href = `/admin/frameworks/wizard?edit=${frameworkId}`;
    }

    // Phase 3: Enhanced Framework Modal with Permission Context
    function enhanceFrameworkModal(frameworkId, isGlobal, isEditable) {
        const modal = document.getElementById('frameworkDetailsModal');
        const modalHeader = modal.querySelector('.modal-header');
        
        if (isGlobal && !isEditable) {
            // Add read-only indicator to modal header
            modalHeader.classList.remove('bg-success');
            modalHeader.classList.add('bg-info');
            
            const modalTitle = modal.querySelector('.modal-title');
            if (!modalTitle.querySelector('.read-only-badge')) {
                const readOnlyBadge = document.createElement('span');
                readOnlyBadge.className = 'badge bg-light text-dark ms-2 read-only-badge';
                readOnlyBadge.innerHTML = '<i class="fas fa-lock"></i> Read-only';
                modalTitle.appendChild(readOnlyBadge);
            }
        } else {
            // Reset to normal styling
            modalHeader.classList.remove('bg-info');
            modalHeader.classList.add('bg-success');
            
            const readOnlyBadge = modal.querySelector('.read-only-badge');
            if (readOnlyBadge) {
                readOnlyBadge.remove();
            }
        }
    }

// Close the domReadyInit IIFE
})();

// Close the outer initWhenReady IIFE
})();